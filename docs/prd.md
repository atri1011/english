# AI场景化例句背单词网站 产品需求文档 (PRD)

## 1. 目标与背景上下文 (Goals and Background Context)

### 目标 (Goals)

* **产品与市场目标:**
    * 在3个月内成功上线MVP，以验证AI场景化例句这一核心概念的市场接受度。
    * 在6个月内获取1,000名活跃用户，确立“AI叙事化学习”的独特品牌定位。
* **用户成功目标:**
    * 显著提升用户的单词记忆保持率（7日后复习正确率）。
    * 通过提供生动、有趣的体验，增强用户的学习动力，提高日活与留存率。
    * 获得用户的高度认可，实现较高的应用评分和例句质量评分（“有帮助”比例 > 80%）。

### 背景上下文 (Background Context)

传统的单词记忆方法普遍依赖机械重复和通用例句，这种方式不仅枯燥乏味，而且严重影响学习动力和记忆效率，导致用户陷入“背了就忘”的无效循环。市场上的主流应用虽然工具丰富，但其例句是静态和标准化的，无法根据用户的个人情境（如学生或职场人士）提供个性化内容，也常常因为在例句中引入过多生词而增加用户的认知负担。

本项目旨在通过创新的AI例句生成引擎从根本上解决这些痛点。我们的核心方案是构建一个能够动态生成具有强烈“画面感”和“场景叙事”风格例句的在线平台。该方案通过提供高度个性化、且优先使用用户已学词汇构建熟悉语境的例句，为用户建立更深刻的“记忆锚点”，将枯燥的记忆过程转变为一种更符合认知科学的、引人入胜的探索体验，从而显著提升学习效率和乐趣。

### 变更日志 (Change Log)

| 日期 | 版本 | 描述 | 作者 |
| :--- | :--- | :--- | :--- |
| 2025-09-01 | 1.0 | 初始草稿创建 | John (PM) |

---

## 2. 需求 (Requirements)

### 功能性需求 (Functional Requirements)

1.  **用户系统:**
    * FR1: 系统必须支持用户通过邮箱和密码进行注册与登录。
2.  **用户画像与个性化:**
    * FR2: 用户在首次使用时，必须能从预设的画像列表（初期包括“备考学生”和“职场人士”）中选择一个。
    * FR3: 系统的AI例句生成引擎必须根据用户选择的画像，调整例句的风格和情境。
3.  **核心学习功能:**
    * FR4: 系统必须提供一个简洁的学习界面，用于展示目标单词、释义，并包含一个用于触发AI生成例句的按钮。
    * FR5: AI例句生成引擎必须能够动态生成符合“场景化叙事”和“词汇关联性”原则的例句。
    * FR6: 每个生成的例句旁必须提供一个简单的“赞/踩”按钮，用于收集用户对例句质量的即时反馈。
4.  **API配置:**
    * FR7: 系统必须提供一个安全的用户设置页面，允许用户输入、保存和更新他们自己的API URL、密钥和模型名称。
    * FR8: 用户的API密钥在数据库中必须经过加密存储，绝不能以明文形式保存。
5.  **词书管理:**
    * FR9: 系统必须为用户提供预设的标准化词书（例如：CET-4、CET-6、考研核心词汇、商务英语词汇等）。
    * FR10: 用户必须能够以标准格式（如CSV或JSON）导入自己的自定义词书。 (注：此功能不在MVP范围内，将在后续版本中实现)
    * FR11: 用户可以在不同的词书之间进行切换，以选择当前希望学习的词汇范围。

### 非功能性需求 (Non-Functional Requirements)

* **性能 (Performance):**
    * NFR1: 页面加载时间应在3秒以内。
    * NFR2: AI例句的生成过程必须有明确的加载状态指示，超时时间设为15秒。
* **可用性 (Usability):**
    * NFR3: 网站界面必须采用响应式设计，以适应不同尺寸的屏幕。
    * NFR4: API密钥的设置流程必须有清晰的引导和说明，以降低用户的操作门槛。
* **安全 (Security):**
    * NFR5: 所有用户数据，特别是API密钥，在传输和存储过程中都必须加密。
* **可扩展性 (Scalability):**
    * NFR6: 系统架构应设计为无服务器（Serverless），以支持未来用户量的平滑增长，并控制运营成本。

---

## 3. 用户界面设计目标 (User Interface Design Goals)

### 整体UX愿景 (Overall UX Vision)

我们的目标是创造一个**简洁、专注、无干扰**的学习环境。用户体验的核心应围绕“单词 -> 场景化例句 -> 记忆”这一核心流程。界面的设计应引导用户专注于当前的学习任务，避免不必要的元素分散其注意力，同时在交互上给予及时、清晰的反馈，营造一种流畅、智能的工具感。

### 关键交互范式 (Key Interaction Paradigms)

* **单任务流:** 用户在学习界面时，主要交互是“请求新例句”和“反馈例句质量”，这是一个线性的、重复性的核心循环。
* **一次性设置:** 用户画像选择和API密钥设置是一次性或低频操作，应设计得清晰易懂，引导用户快速完成配置。
* **即时反馈:** 用户的每一个关键操作（如生成例句、点赞/踩）都应有即时的视觉反馈（如加载动画、按钮状态变化）。

### 核心屏幕与视图 (Core Screens and Views)

根据MVP范围，以下是应用所需的核心界面：
1.  **注册/登录页:** 用于用户账户的创建和访问。
2.  **用户画像选择页:** 新用户首次登录后的一次性选择界面（学生/职场人士）。
3.  **核心学习页:** 展示单词、词义、AI例句生成按钮和例句展示区域的核心界面。
4.  **API设置页:** 供用户输入、修改和保存其个人API URL、密钥和模型。

### 可访问性 (Accessibility): WCAG AA

我们建议我们的无障碍标准目标为 **WCAG 2.1 AA**。这是一个行业内的通用标准，能确保我们的应用对大多数用户（包括有视觉或运动障碍的用户）都是可用的。

### 品牌 (Branding)

目前品牌风格待定。初步建议采用现代、简洁、科技感的设计风格，以建立用户对我们AI能力的信任感。配色应清晰、对比度高，有利于长时间阅读。

### 目标设备与平台 (Target Device and Platforms): Web Responsive

MVP将是一个**响应式的Web应用**，能够在桌面、平板和手机浏览器上提供一致且良好的用户体验。

---

## 4. 技术假设 (Technical Assumptions)

### 代码仓库结构 (Repository Structure): Monorepo

* 我们将采用 Monorepo（单一代码仓库）的结构。
    * **理由:** 这种结构非常适合全栈 TypeScript 项目，可以方便地在前端和后端之间共享代码（例如类型定义、工具函数），简化了构建流程和依赖管理，对于初期的小团队开发尤其高效。

### 服务架构 (Service Architecture): Serverless

* 我们将采用 Serverless（无服务器）架构。
    * **理由:** 这与项目简介中“低运营成本”的核心约束完全一致。Serverless 功能（例如 Vercel Functions）能够按需使用、自动扩展，并且与我们首选的托管平台（Vercel）无缝集成，极大地简化了后端部署和维护工作。

### 测试需求 (Testing Requirements)

* MVP 阶段的测试重点是**单元测试 (Unit Testing)**。
    * **理由:** 我们需要确保核心的业务逻辑（例如例句生成逻辑的封装）和关键的UI组件是可靠的。在MVP阶段，专注于单元测试是投入产出比最高的方式，能保证代码质量，同时不会过度增加开发负担。

### 其他技术假设与请求 (Additional Technical Assumptions and Requests)

* **前端:** Next.js (版本 14+) + TypeScript。
* **后端:** Node.js (LTS 版本) + TypeScript，以 Serverless Functions 的形式部署。
* **数据库:** Supabase (PostgreSQL)。
* **托管平台:** Vercel。
* **核心API集成:** 系统的核心是安全地代理用户请求到他们自己配置的、与 OpenAI API 兼容的 `v1/chat/completions` 接口。

---

## 5. 史诗列表 (Epic List)

* **史诗 1: 项目基础与核心用户设置 (Project Foundation & Core User Setup)**
    * **目标:** 建立项目的技术基础，允许用户完成注册、登录，并能安全地配置他们自己的API密钥，为核心学习功能的实现做好准备。

* **史诗 2: 核心学习体验与MVP交付 (Core Learning Experience & MVP Delivery)**
    * **目标:** 实现MVP的核心价值主张，让配置好API密钥的用户能够基于预设词书和个人画像，获得由AI动态生成的场景化例句，并提供反馈。

---

## 6. 史诗 1: 项目基础与核心用户设置 (Project Foundation & Core User Setup)

**扩展目标:** 此史诗旨在构建应用的完整技术骨架和面向用户的核心设置流程。在完成此史诗后，我们将拥有一个可部署、安全的应用外壳。用户将能够创建账户、登录，并安全地管理其个人API配置，为下一阶段的核心学习功能做好万全准备。

#### 故事 1.1: 项目初始化与部署设置
* **作为一个** 项目所有者, **我想要** 一个初始化好的 Next.js Monorepo 项目，并将其配置好在 Vercel 上进行自动化部署, **以便于** 我们拥有一个稳固的、具备持续集成/持续部署（CI/CD）能力的技术基础和一个可供后续开发的实时网址。
* **验收标准:**
    1.  一个新的 Monorepo 仓库已创建，其中包含一个使用 Next.js 和 TypeScript 的 Web 应用包。
    2.  项目已连接到一个 Git 仓库（如 GitHub）。
    3.  一个基础的欢迎页面或应用入口已成功部署到一个 Vercel 的公开 URL 上。
    4.  Vercel 部署流程已配置为在代码推送到主分支时自动触发。

#### 故事 1.2: 用户数据模式与数据库设置
* **作为一个** 开发者, **我想要** 建立 Supabase 项目并为用户及他们加密后的API配置定义好数据库模式, **以便于** 我们有一个安全、可靠的基础来存储所有用户数据。
* **验收标准:**
    1.  一个新的 Supabase 项目已创建并与 Vercel 项目连接。
    2.  `users` 表已创建，并与 Supabase 的认证（Auth）服务集成。
    3.  一个独立的 `user_api_configs` 表已创建，包含 `user_id`（关联用户）、`api_url`、`encrypted_api_key` 和 `model_name` 等字段。
    4.  `encrypted_api_key` 字段绝不能以明文形式存储 API 密钥。
    5.  数据库已启用行级安全（RLS）策略，确保用户只能访问和修改自己的 API 配置。

#### 故事 1.3: 用户注册功能
* **作为一个** 新访客, **我想要** 使用我的邮箱和密码注册一个新账户, **以便于** 我可以开始使用这个应用。
* **验收标准:**
    1.  应用提供一个包含邮箱和密码输入框的注册表单。
    2.  成功提交后，将在 Supabase Auth 中创建一个新用户。
    3.  用户在注册后会自动登录，并被重定向到应用主页。
    4.  当输入的邮箱格式无效或该邮箱已被注册时，会向用户显示清晰的错误提示。

#### 故事 1.4: 用户登录与会话管理
* **作为一个** 已注册用户, **我想要** 使用我的邮箱和密码登录，并在不同浏览器会话中保持登录状态, **以便于** 我可以方便、安全地访问我的账户。
* **验收标准:**
    1.  应用提供一个包含邮箱和密码输入框的登录表单。
    2.  成功登录后，用户被重定向到应用主页。
    3.  应用能够通过会话（Session）机制，在用户关闭并重新打开浏览器后保持其登录状态。
    4.  应用提供一个功能明确的“退出登录”按钮，点击后能清除用户的会话。
    5.  当输入的凭证不正确时，会向用户显示清晰的错误提示。

#### 故事 1.5: API 配置页面
* **作为一个** 已登录用户, **我想要** 一个专属的设置页面，用来输入、查看和更新我的 AI 服务 API URL、API 密钥和模型名称, **以便于** 我可以将应用连接到我自己的 AI 服务。
* **验收标准:**
    1.  应用中有一个“API 设置”页面，且此页面仅对已登录用户可见。
    2.  页面包含用于输入 API URL、API 密钥（输入时应被遮蔽）和模型名称的表单字段。
    3.  如果用户已有配置，再次进入此页面时，表单会预先填入已保存的 API URL 和模型名称（API 密钥不应被明文显示）。
    4.  页面上有一个功能明确的“保存”按钮。
    5.  页面上有清晰的文字说明，解释每个字段的用途和如何获取这些信息。

#### 故事 1.6: 安全保存 API 配置
* **作为一个** 已登录用户, **我想要** 在我保存 API 配置时，系统能够安全地加密并存储我的 API 密钥, **以便于** 保护我的凭证信息不被泄露。
* **验收标准:**
    1.  用户点击“保存”时，表单数据会被发送到一个安全的后端 Serverless Function。
    2.  该后端功能在将 API 密钥存入数据库前，必须对其进行加密处理。
    3.  API 密钥在数据库的任何地方都绝不能以明文形式存储。
    4.  API URL 和模型名称与加密后的密钥一同被保存或更新。
    5.  保存成功后，前端界面会给用户一个明确的成功提示。
    6.  后端功能必须验证操作者身份，确保用户只能修改自己的配置。

---

## 7. 史诗 2: 核心学习体验与MVP交付 (Core Learning Experience & MVP Delivery)

**扩展目标:** 此史诗将在已建立的用户和技术基础上，交付产品的核心价值。完成此史诗后，用户将能够选择他们的学习画像，从预设词书中学习单词，并利用他们配置好的API密钥，实时生成独特的、符合其个人情境的场景化例句。这将完成我们MVP的闭环，使其准备好迎接首批用户并验证核心市场假设。

#### 故事 2.1: 用户画像选择
* **作为一个** 首次使用的用户, **我想要** 在开始学习前，选择一个符合我学习目标的画像（如“备考学生”或“职场人士”), **以便于** AI生成的例句能够与我的学习和工作情境高度相关。
* **验收标准:**
    1.  用户在首次登录并完成API设置后，会被引导至一个一次性的用户画像选择页面。
    2.  页面上清晰地展示了“备考学生”和“职场人士”两个可选的画像。
    3.  用户的选择将被成功保存到其在数据库中的个人记录里。
    4.  选择完成后，用户被自动引导至核心学习页面。
    5.  在后续的访问中，用户不会再次看到此选择页面。

#### 故事 2.2: 实现并选择预设词书
* **作为一个** 用户, **我想要** 应用中包含多个高质量的预设词书（例如 CET-4 核心词汇）, **以便于** 我可以立即从一个标准化的词汇列表开始学习。
* **验收标准:**
    1.  系统中至少预置了两本词书（例如：“CET-4核心词汇”、“商务英语核心500词”），这些词书可以作为项目内的静态资源（如JSON文件）存在。
    2.  在学习界面中，有一个清晰的下拉菜单或选项，允许用户查看并选择他们想要学习的词书。
    3.  用户的词书选择被记录下来，下次登录时应用会默认加载该词书。

#### 故事 2.3: 核心学习界面
* **作为一个** 用户, **我想要** 一个简洁的学习界面，能够一次展示一个来自我所选词书的单词及其释义, **以便于** 我可以集中注意力进行学习。
* **验收标准:**
    1.  核心学习页面顶部清晰地展示了当前学习的单词。
    2.  单词下方展示了其最核心的中文释义。
    3.  页面上有一个非常醒目的“生成场景例句”按钮。
    4.  页面提供“上一个”和“下一个”的导航功能，让用户可以在当前词书中切换单词。
    5.  按钮下方预留了专门的区域，用于展示即将生成的例句。

#### 故事 2.4: 后端AI代理与提示词工程
* **作为一个** 开发者, **我需要** 一个安全的后端功能，它能获取用户的API配置、构建一个专业的提示词（Prompt）、并将请求代理转发到用户指定的AI端点, **以便于** 系统能够生成高度个性化的场景例句。
* **验收标准:**
    1.  已创建一个只能由已认证用户调用的安全 Serverless Function。
    2.  该功能能够根据当前用户的ID，从数据库中获取其加密的API密钥和相关配置。
    3.  API密钥仅在请求期间于内存中解密使用，绝不泄露。
    4.  该功能会根据预设的模板，动态构建一个包含【目标单词】、【用户画像】及【来自同一词书的几个关联词】的复杂提示词。
    5.  该功能使用用户的API URL、解密后的密钥和模型名称，向兼容OpenAI的 `/v1/chat/completions` 接口发起POST请求。
    6.  成功获取AI的响应后，后端能准确解析出例句内容并返回给前端。
    7.  对所有可预见的错误（如API密钥无效、网络超时、AI服务返回错误等）都进行了妥善处理。

#### 故事 2.5: 展示生成的例句与反馈UI
* **作为一个** 用户, **我想要** 在请求例句后，能清晰地看到AI生成的内容，并能方便地对其质量进行反馈, **以便于** 我能有效地学习，并帮助系统（的提示词）变得更好。
* **验收标准:**
    1.  点击“生成场景例句”按钮后，界面会显示一个加载动画，表示正在处理中。
    2.  成功获取例句后，加载动画消失，生成的例句内容会流畅地展示在预留区域。
    3.  如果生成失败，则会显示一条对用户友好的错误提示信息。
    4.  生成的例句旁边，会显示“赞”和“踩”两个清晰的图标按钮。

#### 故事 2.6: 存储用户对例句的反馈
* **作为一个** 产品所有者, **我想要** 存储用户对每个例句的“赞/踩”反馈, **以便于** 我们能够分析和评估提示词工程的有效性，并为未来的优化提供数据支持。
* **验收标准:**
    1.  当用户点击“赞”或“踩”按钮时，该反馈会被异步地记录到数据库中。
    2.  存储的记录应至少包含：目标单词、生成的例句、反馈类型（赞/踩）、用户ID和时间戳。
    3.  用户提交反馈后，按钮会变为“已提交”状态（例如变灰或消失），以防止重复提交。
    4.  反馈的提交过程不会影响用户继续学习下一个单词。

---